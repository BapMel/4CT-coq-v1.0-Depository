(* (c) Copyright Microsoft Corporation and Inria. All rights reserved. *)
Require tacticext.
Require boolprop.
Require funs.
Require dataset.
Require natprop.
Require seq.
Require paths.
Require finset.
Require connect.
Require hypermap.
Require geometry.
Require quiztree.
Require part.
Require znat.
Require discharge.

Set Implicit Arguments.

(* Ruling out a part using a combination of discharging and reducibility.    *)
(* In principle, this brings together almost all the elements of the proof   *)
(* development, so for modularity we only import a predicate on parts from   *)
(* the reducibility half, with the assumption that it is always false when   *)
(* the part fits the map. We'll tie up everithing in present.v (anyway,      *)
(* we can't really use the reducibility check in recursive functions, that   *)
(* causes the recursion check to diverge).                                   *)

(* The hubcap concrete syntax is used directly in the source file, so the    *)
(* sector indices start at 1 in the concrete syntax, and are shifted by the  *)
(* parsing and pretty-printing. An additional shift by 2 is done during the  *)
(* verification, to line up with the rules.                                  *)

(* We also define a simpler source cap check, which is used in present12.v   *)
(* to exclude hub sizes greater than 11 (using lemma dscore_cap1).           *)

(* The sequence structure of hubcaps is compressed, not for speed, but to    *)
(* save space in the large proofs generated by the presentation scripts.     *)

Inductive hubcap : Set :=
  Hubcap0 : hubcap
| Hubcap1 : nat -> znat -> hubcap -> hubcap
| Hubcap2 : nat -> nat -> znat -> hubcap -> hubcap.

Grammar constr constr10 : constr :=
  hubcap_expr [ "Hubcap" hubcap($p) ] -> [$p]
with hubcap : constr :=
  hubcap2
    ["T" "[" hcindex($j1) ";" hcindex($j2) "]" "<=" znat_lit($b)
      hubcap_tail($h)] ->
  [(Hubcap2 $j1 $j2 $b $h)]
| hubcap1
    ["T" "[" hcindex($j) "]" "<=" znat_lit($b) hubcap_tail($h)] ->
  [(Hubcap1 $j $b $h)]
with hubcap_tail : constr :=
  some_hubcap_tail ["&" hubcap($h)] -> [$h]
| no_hubcap_tail [ ] -> [Hubcap0]
with hcindex : constr :=
  hcindex_expr [ nat:number($j) ] ->
  let (APPLIST $_ $j') = [$j] in [$j'].

(* Pretty-printing turns on automatically when the first index is instantiated *)
Syntax constr level 10 :
  pp_hubcap_call [(Pretty hubcap $h)] ->
  ["Hubcap" [<hov 1> (PPHUBCAP $h)]]
| pp_hubcap_default [<<(PPHUBCAP $h)>>] ->
  [" (" $h:L ":: hubcap)"]
| pp_hubcap1 [<<(PPHUBCAP <<(Hubcap1 $j $b $h)>>)>>] ->
  [" T[" <<(S $j)>> "] <= " <<(Pretty znat $b)>> (PPHUBCAPT $h)]
| pp_hubcap2 [<<(PPHUBCAP <<(Hubcap2 $j1 $j2 $b $h)>>)>>] ->
  [" T[" <<(S $j1)>> ";" <<(S $j2)>> "] <= " <<(Pretty znat $b)>> (PPHUBCAPT $h)]
| pp_hubcap0 [<<(PPHUBCAP <<Hubcap0>>)>>] ->
  [ ]
| pp_hubcapt_default [<<(PPHUBCAPT $h)>>] ->
  [[1 0] "&" (PPHUBCAP $h)]
| pp_hubcapt0 [<<(PPHUBCAPT <<Hubcap0>>)>>] ->
  [ ]
| pp_hubcap1_implicit0 [(Hubcap1 (0) $b $h)] ->
  [<<(Pretty hubcap (Hubcap1 (0) $b $h))>>]
| pp_hubcap1_implicitS [(Hubcap1 (S $j) $b $h)] ->
  [<<(Pretty hubcap (Hubcap1 (S $j) $b $h))>>]
| pp_hubcap2_implicit0 [(Hubcap2 (0) $j2 $b $h)] ->
  [<<(Pretty hubcap (Hubcap2 (0) $j2 $b $h))>>]
| pp_hubcap2_implicitS [(Hubcap2 (S $j1) $j2 $b $h)] ->
  [<<(Pretty hubcap (Hubcap2 (S $j1) $j2 $b $h))>>].

Section Hubcap.

Variables nhub : nat; redp : part -> bool; rf : (drule_fork nhub).
Local rs0 : drules := (source_drules rf).
Local rt0 : drules := (target_drules rf).

Variable g : hypermap.
Hypothesis Hg : (plain_cubic_pentagonal g).
Local HgF : (pentagonal g) := Hg.
Hypothesis Hredp : (x : g; p : part) (redp p) -> (negb (exact_fitp x p)).

(* Source bound checking.                                                   *)

Fixpoint check_dbound1_rec [p : part; rs : drules; ns, m : nat] : bool :=
  if m is (S m') then
    if rs is (Adds r rs') then
      if (ltn (size rs') ns) then true else
      let p' = (meet_part p r) in
      (andb let (dns, rs'') = (sort_drules p' rs') in
            if (minus ns dns) is (S ns') then
              (check_dbound1_rec p' rs'' ns' m')
            else (redp p')
         (check_dbound1_rec p rs' ns m'))
    else true
  else false.

Definition check_dbound1 [p : part; ns : nat] : bool :=
  let (rs, _, _) = rf in (check_dbound1_rec p rs ns (plus (size rs) (1))).

Lemma check_dbound1P : (x : g; p : part; ns : nat)
  (arity x) = nhub -> (exact_fitp x p) -> (check_dbound1 p ns) ->
  (leq (dbound1 rs0 x) ns).
Proof.
Move=> x p ns Hxn; Rewrite: /check_dbound1 /rs0 /source_drules.
Case: {}rf => [rs rt _] {rt}; Def: m := (plus (size rs) (1)).
Elim: m ns rs p => // [m Hrec] ns [|r rs] //= p Hxp.
Case Hns: (ltn (size rs) ns).
  Clear; Apply: leq_trans Hns.
  By Rewrite: -add1n; Apply leq_add2; [Case (fitp x r) | Apply: count_size].
Rewrite: subnI; Pose p' := (meet_part p r); Case/andP {Hn}.
Case Hxr: (fitp x r); RightBy Clear; Apply: Hrec => //=; Rewrite Hxr.
Step Exp' : (exact_fitp x p') By Apply: exact_fitp_meet.
Case/andP: {}Exp' => [_ Hxp'].
Case: (sort_drulesP Hxp' rs) => [dns rs'].
Case Dns': (subn ns dns) => [|ns']; LeftBy Move=> *; Case/idPn: Exp'; Auto.
Step Hns': (ltn dns ns) By Rewrite: ltn_lt0sub Dns'.
Move=> Hrsp' _; Rewrite: -(leq_add_sub (ltnW Hns')) Dns' /=.
Rewrite: add1n addnS ltnS leq_add2l; EAuto.
Qed.

Fixpoint check_unfit [p : part; ru : drules] : bool :=
  if ru is (Adds r ru') then
    if (cmp_part p r) is Psubset then true else (check_unfit p ru')
  else false.

Lemma check_unfitP : (x : g; p : part; Hxp : (fitp x p); ru : drules)
  (dbound1 ru x) = (0) -> (check_unfit p ru) = false.
Proof.
Move=> x p Hxp; Elim=> [|r ru Hrec] //=.
Case Hxr: (fitp x r)=> // [] Hru; Rewrite: ~{Hrec Hru}(Hrec Hru).
By Rewrite: (fitp_cmp Hxp) in Hxr; Case: (cmp_part p r) Hxr.
Qed.

(* Single target bound checking.                                               *)

Fixpoint check_dbound2_rec [p : part; rt, rs, ru : drules; nt, m : nat] : bool :=
  if m is (S m') then
    if rt is (Adds r rt') then
      if (ltn (size rt') nt) then true else
      let p' = (meet_part p r) in
      (andb if (check_unfit p' ru) then true else
            let (dnt, rt'') = (sort_drules p' rt') in
            let (dns, rs') = (sort_drules p' rs) in
            if (minus (plus dns nt) dnt) is (S nt') then
              (check_dbound2_rec p' rt'' rs' ru nt' m')
            else (redp p')
         (check_dbound2_rec p rt' rs (Adds r ru) nt m'))
    else true
  else false.

Definition check_dbound2 [p : part; b : znat] : bool :=
  let (rs, rt, _) = rf in
  let (dnt, rt') = (sort_drules p rt) in
  let (dns, rs') = (sort_drules p rs) in
  if (addz (subnz (S dns) dnt) b) is (Zpos nt) then
    (check_dbound2_rec p rt' rs' seq0 nt (plus (size rt') (2)))
  else false.

Lemma check_dbound2P : (x : g; p : part; b : znat)
  (arity x) = nhub -> (exact_fitp x p) -> (check_dbound2 p b) ->
 (leqz (dbound2 rt0 rs0 x) b).
Proof.
Move=> x p b Hxn Exp; Rewrite: /check_dbound2 /dbound2.
Rewrite: /rs0 /rt0 /source_drules /target_drules; Case: {}rf => [rs rt _].
Pose ru := (seq0::drules); Step Hru: (dbound1 ru x) = (0) By Done.
Case/andP: {}Exp => [_ Hxp].
Case: {rt}(sort_drulesP Hxp rt) => [dnt rt]; Pose m := (plus (size rt) (2)).
Case: {rs Hxp}(sort_drulesP Hxp rs) => [dns rs].
Case Dnt: (addz (subnz (S dns) dnt) b) => // [nt] Hpnt.
Rewrite: /leqz !zpos_addn subz_sub -oppz_sub -subz_sub oppz_sub leqzI.
Rewrite: -addzA addzC -addz_subA -addzA -(subz_add2l (Znat 1)) {1 2 Zpos}lock.
Rewrite: addzC /= in Dnt; Rewrite: /= ~Dnt -lock -zpos_addn leqz_nat ~{dns dnt}.
Elim: m nt rt rs ru Hru p Exp Hpnt => // [m Hrec] nt [|r rt] //= rs ru Hru p Exp.
Case Hnt: (ltn (size rt) nt).
  Clear; Apply: (leq_trans ? (leq_addl ? ?)); Apply: leq_trans Hnt.
  By Rewrite: -add1n; Apply leq_add2; [Case (fitp x r) | Apply: count_size].
Pose p' := (meet_part p r); Case/andP {Hnt}.
Case Hxr: (fitp x r); RightBy Clear; Apply: (Hrec ? ?) => //=; Rewrite Hxr.
Step Exp' : (exact_fitp x p') By Apply: exact_fitp_meet.
Case/andP: {}Exp' => [_ Hxp'] Hp'rt _; Move: Hp'rt.
Rewrite: (check_unfitP Hxp' Hru) subnI addnI.
Case: {rt}(sort_drulesP Hxp' rt) => [dnt rt].
Case: {Hxp' rs}(sort_drulesP Hxp' rs) => [dns rs].
Case Dnt': (subn (addn dns nt) dnt) => [|nt'].
  By Move=> *; Case/idPn: Exp'; Auto.
Step Hnt': (ltn dnt (addn dns nt)) By Rewrite: ltn_lt0sub Dnt'.
Move=> Hrp'; Rewrite: -!addnA (addnCA dns) -(leq_add_sub (ltnW Hnt')) Dnt' /=.
Rewrite: !(addnC dnt) !addnA leq_add2r addnS add1n ltnS; EAuto.
Qed.

(* Dual target bound check.                                                      *)

Fixpoint check_2dbound2_rec
  [p1, p2 : part; rt1, rs1, ru1, rt2, rs2, ru2 : drules; i, nt, m : nat] : bool :=
  if m is (S m') then
    if rt1 is (Adds r rt1') then
      if (ltn (plus (size rt1') (size rt2)) nt) then true else
      let p1' = (meet_part p1 r) in let p2' = (rot_part i p1') in
      (andb if (orb (check_unfit p1' ru1) (check_unfit p2' ru2)) then true else
            let (dnt1, rt1'') = (sort_drules p1' rt1') in
            let (dns1, rs1') = (sort_drules p1' rs1) in
            let (dnt2, rt2') = (sort_drules p2' rt2) in
            let (dns2, rs2') = (sort_drules p2' rs2) in
            if (minus (plus dns1 (plus dns2 nt)) (plus dnt1 dnt2)) is (S nt') then
              (check_2dbound2_rec p1' p2' rt1'' rs1' ru1 rt2' rs2' ru2 i nt' m')
            else (redp p1')
         (check_2dbound2_rec p1 p2 rt1' rs1 (Adds r ru1) rt2 rs2 ru2 i nt m'))
    else if rt2 is Seq0 then true else
    (check_2dbound2_rec p2 p1 rt2 rs2 ru2 rt1 rs1 ru1 (minus nhub i) nt m')
  else false.

Definition check_2dbound2 [p1 : part; i : nat; b : znat] : bool :=
  let p2 = (rot_part i p1) in
  let (rs, rt, _) = rf in
  let (dnt1, rt1) = (sort_drules p1 rt) in
  let (dns1, rs1) = (sort_drules p1 rs) in
  let (dnt2, rt2) = (sort_drules p2 rt) in
  let (dns2, rs2) = (sort_drules p2 rs) in
  if (addz (subnz (S (addn dns1 dns2)) (addn dnt1 dnt2)) b) is (Zpos nt) then
    let m = (plus (size rt1) (plus (size rt2) (3))) in
    (check_2dbound2_rec p1 p2 rt1 rs1 seq0 rt2 rs2 seq0 i nt m)
  else false.

Lemma check_2dbound2P : (x : g; p : part; i : nat; b : znat)
  (arity x) = nhub -> (exact_fitp x p) -> (leq i nhub) -> (check_2dbound2 p i b) ->
 (leqz (addz (dbound2 rt0 rs0 x) (dbound2 rt0 rs0 (iter i face x))) b).
Proof.
Move=> x1 p1 i b Hx1n Ex1p Hi; Rewrite: /check_2dbound2 /dbound2.
Rewrite: /rs0 /rt0 /source_drules /target_drules; Case: {}rf => [rs rt _].
Pose ru := (seq0::drules); Step Hru: (x : g)(dbound1 ru x) = (0) By Done.
Pose p2 := (rot_part i p1); Pose x2 := (iter i face x1).
Move: ru {2 4}ru {Hru}(Hru x1) (Hru x2) => ru1 ru2 Hru1 Hru2.
Case/andP: {}Ex1p; Rewrite Hx1n; Move/eqP=> Ep1 Hx1p.
Step Ex2p: (exact_fitp x2 p2) By Rewrite: /x2 /p2 -fitp_rot -?Ep1.
Case: (sort_drulesP Hx1p rt) => [dnt1 rt1].
Case: {Hx1p Ep1}(sort_drulesP Hx1p rs) => [dns1 rs1].
Case/andP: {}Ex2p => [_ Hx2p].
Case: {rt}(sort_drulesP Hx2p rt) => [dnt2 rt2].
Def: m := (plus (size rt1) (plus (size rt2) (3))).
Case: {rs Hx2p}(sort_drulesP Hx2p rs) => [dns2 rs2].
Case Dnt: (addz (subnz (S (addn dns1 dns2)) (addn dnt1 dnt2)) b) => // [nt] Hpnt.
Rewrite: !zpos_addn -oppz_sub addzC -oppz_sub -oppz_add -!subz_sub addz_subCA.
Rewrite: subz_sub addz_subA oppz_sub /leqz subz_sub leqzI.
Rewrite: (addzC (Zpos dns1)) (addzC (Zpos dns2)) -!addz_subA -!addzA.
Rewrite: {2 addz}lock addzCA -lock addzA -2!zpos_addn {1 addz}lock addzA.
Rewrite: addz_subCA subz_sub addz_subA -(subz_add2l (Znat 1)) -!zpos_addn addnC.
Rewrite: addnC /= in Dnt; Rewrite: /= ~Dnt -lock -!zpos_addn leqz_nat.
Move: rs1 ru1 p1 Hru1 Ex1p rt2 rs2 ru2 p2 Hru2 Ex2p Hpnt {dns1 dns2 dnt1 dnt2}.
Rewrite: ~/x2.
Elim: m nt x1 i Hx1n Hi rt1 => // [m Hrec] nt x1 i Hx1n Hi [|r rt1] /=.
  Move=> rs1 ru1 p1 Hru1 Ex1p rt2; Case Drt2: rt2 => // [r rt]; Case: {r rt}Drt2.
  Pose x2 := (iter i face x1); Rewrite: subnI; Pose i' := (subn nhub i).
  Move=> rs2 ru2 p2 Hru2 Ex2p; Rewrite: {-3 addn}lock addnC -lock addnC.
  Rewrite: -{(0)}/(dbound1 seq0 x1); Move: (seq0::drules) rs1 ru1 p1 Hru1 Ex1p.
  Step []: (iter i' face x2) = x1.
    Rewrite: /x2 -iter_plus addnI addnC /i' leq_add_sub // -Hx1n.
    Apply iter_face_arity.
  Apply (Hrec nt x2 i'); Auto; [By Rewrite: /x2 arity_iter_face | Apply: leq_subr].
Pose x2 := (iter i face x1).
Move=> rs1 ru1 p1 Hru1 Ex1p rt2 rs2 ru2 p2 Hru2 Ex2p.
Case Hnt: (ltn (plus (size rt1) (size rt2)) nt).
  Clear; Apply: (leq_trans ? (leq_addl ? ?)); Apply: leq_trans Hnt.
  Rewrite: -add1n -addnA addnI; Apply leq_add2; LeftBy Case (fitp x1 r).
  By Apply leq_add2; Apply: count_size.
Pose p1' := (meet_part p1 r); Case/andP {Hnt}.
Case Hxr: (fitp x1 r);
  RightBy Clear; Rewrite: /= add0n /x2; Apply Hrec; Rewrite: //= Hxr.
Step Ex1p' : (exact_fitp x1 p1') By Apply: exact_fitp_meet.
Case/andP: {}Ex1p'; Rewrite: Hx1n; Move/eqP=> Ep1' Hx1p'.
Pose p2' := (rot_part i p1').
Step Ex2p': (exact_fitp x2 p2') By Rewrite: /x2 /p2' -fitp_rot -?Ep1'.
Case/andP: {}Ex2p' => [_ Hx2p'] Hp'nt _; Move: Hp'nt.
Rewrite: (check_unfitP Hx1p' Hru1) (check_unfitP Hx2p' Hru2) subnI addnI /=.
Case: {rt1}(sort_drulesP Hx1p' rt1) => [dnt1 rt1].
Case: {rs1 Hx1p'}(sort_drulesP Hx1p' rs1) => [dns1 rs1].
Case: {rt2}(sort_drulesP Hx2p' rt2) => [dnt2 rt2].
Case: {rs2 Hx2p'}(sort_drulesP Hx2p' rs2) => [dns2 rs2].
Case Dnt': (subn (addn dns1 (addn dns2 nt)) (addn dnt1 dnt2)) => [|nt'].
  By Move=> *; Case/idPn: Ex1p'; Auto.
Step Hnt': (ltn (addn dnt1 dnt2) (addn dns1 (addn dns2 nt))).
  By Rewrite: ltn_lt0sub Dnt'.
Move=> Hrp'; Rewrite: -!addnA !(addnCA dns1) !(addnCA dns2).
Rewrite: -(leq_add_sub (ltnW Hnt')) ~Dnt' add1n !addnS ltnS.
Rewrite: -!addnA -!(addnCA dnt1) -!(addnCA dnt2) !leq_add2l /x2 addnA; EAuto.
Qed.

(* Cover checking; we compute the multiset of indices in a first pass, then *)
(* check coverage.                                                          *)

Fixpoint tally_hubcap [hc : hubcap] : natseq :=
  Cases hc of
    (Hubcap1 i _ hc') => (incr_sub (tally_hubcap hc') i)
  | (Hubcap2 i j _ hc') => (incr_sub (incr_sub (tally_hubcap hc') i) j)
  | _ => seq0
  end.

Fixpoint hubcap_cover_rec [v : natseq; b : znat; hc : hubcap] : bool :=
  Cases hc of
    (Hubcap1 i b' hc') =>
      if (sub (0) v i) is (1) then
       (hubcap_cover_rec v (addz b' (addz b' b)) hc')
      else false
  | (Hubcap2 i j b' hc') =>
      Cases (sub (0) v i) (sub (0) v j) of
        (2) (2) => (hubcap_cover_rec v (addz b' b) hc')
      | (1) (1) => (hubcap_cover_rec v (addz b' (addz b' b)) hc')
      |  _   _  => false
      end
  | Hubcap0 => (negb (posz b))
  end.

Definition hubcap_cover : hubcap -> bool :=
  let b = (dboundK nhub) in let bb = (decz (addz b b)) in
  [hc]let v = (tally_hubcap hc) in
  (and3b (size v) =d nhub (negb (v (0))) (hubcap_cover_rec v bb hc)).

Definition hubcap_rot [j : nat] : part -> part :=
  (rot_part if j is (S (S j')) then j' else (minus (plus nhub j) (2))).

Lemma fit_hubcap_rot : (x : g; p : part)
  (arity x) = nhub -> (exact_fitp x p) ->
  (j : nat) (ltn j nhub) ->
  (exact_fitp (iter j face (inv_face2 x)) (hubcap_rot j p)).
Proof.
Move=> x p Hxn Hxp; Def: Hn := (ltnW (ltnW (ltnW (HgF x)))); Rewrite: Hxn in Hn.
Case/andP: {}Hxp; Rewrite Hxn; Move/eqP=> Ep _.
Case=> [|[|j]] Hj; Rewrite: -?iter_f.
    Rewrite: -(iter_face_arity x) Hxn -(leq_add_sub Hn) /hubcap_rot subnI.
    By Rewrite:  addnI addn0 /inv_face2 /= !Eface -fitp_rot -?Ep ?leq_subr.
  Rewrite: -(iter_face_arity x) Hxn -(leq_add_sub (ltnW Hn)) /hubcap_rot subnI.
  By Rewrite: addnI addn1 subSS /inv_face2 /= Enode Eface -fitp_rot -?Ep ?leq_subr.
By Rewrite: /hubcap_rot /inv_face2 /= !Enode -fitp_rot -?Ep //; Do 3 Apply ltnW.
Qed.

Definition hub_subn [i, j : nat] : nat :=
  (subn if (leq j i) then i else (addn i nhub) j).

Lemma hub_subn_hub : (i, j : nat) (ltn i nhub) -> (ltn j nhub) ->
  (leq (hub_subn i j) nhub).
Proof.
Move=> i j Hi Hj; Rewrite: /hub_subn leq_sub_add.
Case: (leqP j i) => [Hij]; LeftBy Apply: (leq_trans (ltnW Hi)); Apply leq_addl.
By Rewrite leq_add2r; Apply ltnW.
Qed.

Lemma iter_hub_subn : (i, j : nat) (ltn j nhub) -> (x : g) (arity x) = nhub ->
  (iter (hub_subn i j) face (iter j face x)) = (iter i face x).
Proof.
Move=> i j Hj x Hxn; Rewrite: -iter_plus addnI addnC /hub_subn leq_add_sub //.
  By Case (leq j i); RightBy Rewrite: /addn iter_plus -Hxn iter_face_arity.
By Case Hij: (leq j i); RightBy Apply: (leq_trans (ltnW Hj)); Apply leq_addl. 
Qed.

Fixpoint hubcap_fit [p : part; hc : hubcap] : bool :=
  Cases hc of
    (Hubcap1 j b hc') =>
    (andb (check_dbound2 (hubcap_rot j p) b) (hubcap_fit p hc'))
  | (Hubcap2 j1 j2 b hc') =>
    (andb (check_2dbound2 (hubcap_rot j1 p) (hub_subn j2 j1) b)
          (hubcap_fit p hc'))
  | Hubcap0 =>
    true
  end.

Lemma hubcap_fit_bound : (x : g; p : part; hc : hubcap)
  (size_part p) = nhub -> (posz (dscore x)) ->
  (andb (hubcap_cover hc) (hubcap_fit p hc)) ->
  (negb (exact_fitp x p)).
Proof.
Move=> x p hc Ep Hx Hhc; Apply/idP=> [Exp]; Case/andP: {}Exp; Rewrite Ep.
Move/eqP=> Hxn _; Case/idPn: Hx; Case/andP: Hhc; Case/and3P.
Pose v := (tally_hubcap hc); Pose b0 := (dboundK nhub); Move/eqP=> Ev Hv0 Hhc Hhcp.
Pose vb := [v' : natseq] (i : nat) (leq (sub (0) v' i) (sub (0) v i)).
Step Hvb : (v' : natseq; i : nat) (vb (incr_sub v' i)) ->
   (ltn (sub (0) v' i) (sub (0) v i)) /\ (vb v').
  Move=> v' i Hv'; Split; LeftBy Move: (Hv' i); Rewrite: sub_incr_sub set11.
  By Move=> j; Apply: leq_trans (Hv' j); Rewrite: sub_incr_sub leq_addl.
Pose x' := (inv_face2 x).
Pose db2 := [v' : natseq; y : g]
  let b = (dbound2 rt0 rs0 y) in let i = (findex face x' y) in
  Cases (sub (0) v' i) (sub (0) v i) of
    (1) (1) => (addz b b)
  | n _ => (iter n (addz b) (Znat 0))
  end.
Step Hxx': (cface x x') By Rewrite: 2!cface1r /x' /inv_face2 !Enode connect0.
Step Edb2: (v' : natseq; i : nat) (vb (incr_sub v' i)) -> (ltn i nhub) ->
  let y = (iter i face x') in let b = (dbound2 rt0 rs0 y) in
  let is11 = (andb (sub (0) v' i) =d (0) (sub (0) v i) =d (1)) in
  let bb = if is11 then (addz b b) else b in
  (sumz (db2 (incr_sub v' i)) (cface x')) = (addz bb (sumz (db2 v') (cface x'))).
  Move=> v' i Hv' Hi y b is11 bb; Rewrite: -Hxn (arity_cface Hxx') in Hi.
  Rewrite: 2![f](sumz_setID (set1 y) f (cface x')) addzA; Congr addz.
    Step Ex'y: (setI (cface x') (set1 y)) =1 (set1 y).
      Move=> z; Rewrite: /setI andbC; Case: (y =P z) => // [[]].
      By Rewrite: /y fconnect_iter.
    Rewrite: !(eq_sumz_r Ex'y) !sumz_set1 /db2 /= /y findex_iter //.
    Rewrite: sub_incr_sub set11 /= /bb /is11; Case/(Hvb ? ?): Hv'.
    Case: (sub (0) v' i) (sub (0) v i) => [|[|m]] [|[|k]] // _ _.
    By Rewrite addz0.
  Apply: eq_sumz_l => [z]; Move/andP=> [Hyz Hz].
  Rewrite: /db2 sub_incr_sub.
  Case: (i =P (findex face x' z)) => // [Di]; Case/eqP: Hyz.
  By Rewrite: /y Di; Apply iter_findex.
Step Hdb2: (negb (posz (addz (decz (addz b0 b0)) (sumz (db2 v) (cface x'))))).
  Step Hvbv: (vb v) By Move=> i; Apply leqnn.
  Move: (decz (addz b0 b0)) Hvbv Hhc Hhcp => b.
  Rewrite: {1 3}/v -{2 b}subz0 addzC addz_subA -oppz_sub -leq0z sub0z.
  Elim: {}hc b => [|i b' hc' Hrec|j i b' hc' Hrec] b /= Hiv'.
      Rewrite: -(eq_sumz 2!(!zconst g (0))).
        By Rewrite: sumz_const leq0z oppz_opp addzC /= addz0.
      By Move=> y; Rewrite: /db2 /= sub_default.
    Case Dvi: (sub (0) v i) (Hvb ? ? Hiv') => [|[|k]] // [Hiv Hv'] Hhc'.
    Move/andP=> [Hip Hhc'p]; Rewrite: ltnS leqn0 in Hiv.
    Case: (leqP nhub i) => [Hi]; LeftBy Rewrite: sub_default ?Ev in Dvi.
    Apply: (leqz_trans (Hrec ? Hv' Hhc' Hhc'p)) {Hrec Hv' Hhc' Hhc'p}.
    Rewrite: leqz_opp2 Edb2 // Dvi Hiv /= !addzA leqz_add2r ~{b}.
    Rewrite: addzC -addzA leqz_add2l ~{db2 Edb2}.
    Def: Hx'p := (fit_hubcap_rot Hxn Exp Hi).
    Rewrite: (arity_cface Hxx') -(arity_iter_face i x') in Hxn.
    By Apply leqz_add2; Exact (check_dbound2P Hxn Hx'p Hip).
  Case Dvi: (sub (0) v i) (Hvb ? ? Hiv') => [|[|[|k]]] // [Hiv Hjv'];
    Case Dvj: (sub (0) v j) (Hvb ? ? Hjv') => [|[|[|k']]] // [Hjv Hv'] Hhc'.
    Move/andP=> [Hijp Hhc'p]; Rewrite: !ltnS !leqn0 in Hiv Hjv.
    Case: (leqP nhub i) => [Hi]; LeftBy Rewrite: sub_default ?Ev in Dvi.
    Case: (leqP nhub j) => [Hj]; LeftBy Rewrite: sub_default ?Ev in Dvj.
    Apply: (leqz_trans (Hrec ? Hv' Hhc' Hhc'p)) {Hrec Hv' Hhc' Hhc'p}.
    Rewrite: leqz_opp2 !Edb2 // Dvi Dvj Hiv Hjv /= !addzA leqz_add2r addzC ~{b}.
    Rewrite: -!addzA leqz_add2l addzC addzCA !addzA -addzA ~{db2 Edb2}.
    Def: Hx'p := (fit_hubcap_rot Hxn Exp Hj); Rewrite: (arity_cface Hxx') in Hxn.
    Rewrite: -(iter_hub_subn i Hj Hxn); Rewrite: -(arity_iter_face j x') in Hxn.
    Apply leqz_add2; Exact (check_2dbound2P Hxn Hx'p (hub_subn_hub Hi Hj) Hijp).
  Move/andP=> [Hijp Hhc'p]; Rewrite: !ltnS in Hiv Hjv.
  Case: (leqP nhub i) => [Hi]; LeftBy Rewrite: sub_default ?Ev in Dvi.
  Case: (leqP nhub j) => [Hj]; LeftBy Rewrite: sub_default ?Ev in Dvj.
  Apply: (leqz_trans (Hrec ? Hv' Hhc' Hhc'p)) {Hrec Hv' Hhc' Hhc'p}.
  Rewrite: leqz_opp2 !Edb2 // Dvi Dvj !andbF /= !addzA leqz_add2r ~{b}.
  Rewrite: addzC leqz_add2l ~{db2 Edb2} addzC.
  Def: Hx'p := (fit_hubcap_rot Hxn Exp Hj); Rewrite: (arity_cface Hxx') in Hxn.
  Rewrite: -(iter_hub_subn i Hj Hxn); Rewrite: -(arity_iter_face j x') in Hxn.
  Exact (check_2dbound2P Hxn Hx'p (hub_subn_hub Hi Hj) Hijp).
Pose db := (addz b0 (sumz (dbound2 rt0 rs0) (cface x'))).
Cut ~(posz (decz (addz db db))).
  Move=> H; Apply/idP=> [Hx]; Case: H; Move: (dscore_cap2 rf Hg Hxn Hx).
  Rewrite: -/rs0 -/rt0 -/b0 (eq_sumz_r (same_cface Hxx')) -/db.
  By Rewrite: decz_def -addzA; Case: db => [[|n]|n].
Apply: negP; Apply: etrans Hdb2 {p Ep Exp vb Hvb Edb2 Hhcp}; Congr negb.
Congr posz; Rewrite: !decz_def -!(addzC (Znat -1)) -!addzA; Congr addz.
Rewrite: /db -!addzA; Congr addz; Rewrite: addzCA -sumz_add; Congr addz.
Apply: eq_sumz_l => [y Hy]; Rewrite: ~/db2.
Def: b := (dbound2 rt0 rs0 y); Pose i := (findex face x' y).
Step Hi: (ltn i nhub) By Rewrite: -Hxn (arity_cface Hxx'); Apply: findex_max.
Case Hi0: ((sub (0) v i) =d (0)).
  By Case/idP: Hv0; Rewrite: -(eqP Hi0) mem_sub ?Ev.
Case Dvi: (sub (0) v i) {}Hi0 => [|[|[|k]]] //=; LeftBy Rewrite: addz0.
Case/eqP: Hi0 {b Ev Hv0}; Rewrite: /v.
Move: v Dvi (decz (addz b0 b0)) Hhc => v Dvi.
Elim: hc => [|j b' hc' Hrec|j1 j2 b' hc' Hrec] b /=; Try By Case i.
  Rewrite: sub_incr_sub; Case: (j =P i) => [Dj | _]; LeftBy Rewrite: Dj Dvi.
  By Case: (sub (0) v j) => [|[|k']] //; Apply: Hrec.
Rewrite: !sub_incr_sub; Case: (j1 =P i) => [Dj1 | _]; LeftBy Rewrite: Dj1 Dvi.
Case: (sub (0) v j1) => [|[|[|k1]]] //;
  (Case: (j2 =P i) => [Dj2 | _]; LeftBy Rewrite: Dj2 Dvi);
  Case: (sub (0) v j2) => [|[|[|k2]]] //; Apply: Hrec.
Qed.

End Hubcap.

Unset Implicit Arguments.
